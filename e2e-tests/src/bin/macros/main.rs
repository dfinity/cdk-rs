use ic_cdk::{export_candid, update};
use prost::Message;
use std::marker::PhantomData;

#[update(decode_with = "decode_arg0")]
fn arg0() {}
fn decode_arg0(_arg_bytes: Vec<u8>) {}

#[update(decode_with = "decode_arg1")]
fn arg1(a: u32) {
    assert_eq!(a, 1);
}
fn decode_arg1(arg_bytes: Vec<u8>) -> u32 {
    candid::utils::decode_one(&arg_bytes).unwrap()
}

#[update(decode_with = "decode_arg2")]
fn arg2(a: u32, b: u32) {
    assert_eq!(a, 1);
    assert_eq!(b, 2);
}
fn decode_arg2(arg_bytes: Vec<u8>) -> (u32, u32) {
    candid::utils::decode_args(&arg_bytes).unwrap()
}

#[update(encode_with = "encode_ret0")]
fn ret0() {}
fn encode_ret0() -> Vec<u8> {
    vec![0]
}

#[update(encode_with = "encode_ret1")]
fn ret1() -> u32 {
    42
}
fn encode_ret1(v1: u32) -> Vec<u8> {
    vec![v1 as u8]
}

#[update(encode_with = "encode_ret2")]
fn ret2() -> (u32, u32) {
    (1, 2)
}
fn encode_ret2(ret: (u32, u32)) -> Vec<u8> {
    vec![ret.0 as u8, ret.1 as u8]
}

// The type binding is generated by the build.rs script in the `e2e-tests` directory.
mod canister {
    include!(concat!(env!("OUT_DIR"), "/canister.rs"));
}
use canister::*;

/// The following two methods demonstrate how to use generic decode/encode functions.
/// They take different types of arguments and return values.
/// While the decode/encode functions are generic and can be used for both entry points.
#[update(decode_with = "from_proto_bytes", encode_with = "to_proto_bytes")]
fn method_one(arg: MethodOneRequest) -> MethodOneResponse {
    MethodOneResponse {
        result: arg.input.len() as i32,
    }
}
#[update(decode_with = "from_proto_bytes", encode_with = "to_proto_bytes")]
fn method_two(arg: MethodTwoRequest) -> MethodTwoResponse {
    MethodTwoResponse {
        success: arg.values.iter().sum::<f32>() > 0.0,
        message: "Hello world!".to_string(),
    }
}
fn to_proto_bytes<T: Message>(msg: T) -> Vec<u8> {
    msg.encode_to_vec()
}
fn from_proto_bytes<T: Message + Default>(msg: Vec<u8>) -> T {
    Message::decode(&msg[..]).unwrap()
}

/// The following method demonstrates how to specify `guard`/`decode_with`/`encode_with` attributes with generic parameters.
#[update(
    guard = "generic_guard::<0>", // N = 0, any input length is accepted
    decode_with = "custom_candid_decode::<10000,_>",
    encode_with = "custom_candid_encode::<100,_>"
)]
fn generic(a: u32) -> u32 {
    a + 1
}

// A guard to verify the length of the input data is at least N bytes (N is specified as a const generic parameter).
fn generic_guard<const N: usize>() -> Result<(), String> {
    let input = ic_cdk::api::msg_arg_data();
    if input.len() < N {
        Err("generic_guard failed".to_string())
    } else {
        Ok(())
    }
}

// A Candid decode function that uses a custom decoding quota N which is specified as a const generic parameter.
fn custom_candid_decode<const N: usize, T: for<'a> candid::Deserialize<'a> + candid::CandidType>(
    bytes: Vec<u8>,
) -> T {
    let mut config = candid::de::DecoderConfig::new();
    config.set_decoding_quota(N);
    candid::utils::decode_one_with_config(&bytes[..], &config).unwrap()
}

// A Candid encode function that checks the length of the encoded bytes is less than N which is specified as a const generic parameter.
fn custom_candid_encode<const N: usize, T: candid::CandidType>(v: T) -> Vec<u8> {
    let bytes = candid::utils::encode_one(v).unwrap();
    assert!(bytes.len() < N);
    bytes
}

#[update(manual_reply = true)]
fn manual_reply() -> PhantomData<u32> {
    let v: u32 = 1;
    let reply_bytes = candid::encode_one(v).unwrap();
    ic_cdk::api::msg_reply(reply_bytes);
    PhantomData
}

#[update(guard = "guard1", guard = "guard2")]
fn with_guards() {}

fn guard1() -> Result<(), String> {
    let input = ic_cdk::api::msg_arg_data();
    if !input[0].is_multiple_of(3) {
        Err("guard1 failed".to_string())
    } else {
        Ok(())
    }
}

fn guard2() -> Result<(), String> {
    let input = ic_cdk::api::msg_arg_data();
    if !input[0].is_multiple_of(5) {
        Err("guard2 failed".to_string())
    } else {
        Ok(())
    }
}

// This method will be called with "malicious" payloads.
// We expected that a default skipping_quota (10_000) is set in the update/query macros.
// This will trigger a decoding error when the payload exceeds the quota.
#[update]
fn default_skipping_quota(_arg: Option<u32>) {}

export_candid! {}

fn main() {
    println!("{}", __export_service());
}

#[cfg(test)]
mod tests {
    use candid_parser::utils::{service_equal, CandidSource};

    #[test]
    fn candid_equality_test() {
        // If `decode_with` is specified, the argument type would be `blob` in Candid.
        // If `encode_with` is specified, the return type would be `blob` in Candid.
        let expected = "service : {
            arg0 : (blob) -> ();
            arg1 : (blob) -> ();
            arg2 : (blob) -> ();
            ret0 : () -> (blob);
            ret1 : () -> (blob);
            ret2 : () -> (blob);
            method_one : (blob) -> (blob);
            method_two : (blob) -> (blob);
            generic : (blob) -> (blob);
            manual_reply : () -> (nat32);
            with_guards : () -> ();
            default_skipping_quota : (opt nat32) -> ();
          }";
        let expected_candid = CandidSource::Text(expected);

        let actual = super::__export_service();
        let actual_candid = CandidSource::Text(&actual);

        let result = service_equal(expected_candid, actual_candid);
        assert!(result.is_ok(), "{:?}", result.unwrap_err());
    }
}
